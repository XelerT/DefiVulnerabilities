### Structure

    src  - sources with vulnerable smart contracts
    test - files that will be run by forge

# Описание реализованных уязвимостей (Vulnerability Showcase)


---

### 1. Arbitrary External Call (SushiSwap RouteProcessor2)
* **Тип:** Нарушение валидации входных данных (Input Validation) / Access Control.
* **Механика:** Смарт-контракт роутера слепо доверяет параметрам маршрутизации (`route`), переданным пользователем, и декодирует из них адрес пула без проверки по «белому списку». Атакующий подставляет в маршрут адрес своего вредоносного контракта. Роутер, следуя инструкции, отправляет токены пользователя (или свои) на этот адрес, где вредоносный код похищает их вместо выполнения обмена.

### 2. Token Callback Reentrancy (Omni Protocol / NFT)
* **Тип:** Атака повторного входа (Reentrancy) через стандарты токенов (ERC-721, ERC-777, ERC-1155).
* **Механика:** Протокол нарушает паттерн **Checks-Effects-Interactions**: он сначала отправляет актив (NFT) пользователю, и только потом обновляет запись о долге или залоге. Токены стандарта ERC-721 при получении автоматически вызывают функцию-хук (`onERC721Received`) у получателя. Атакующий использует этот момент, чтобы повторно вызвать функцию протокола (например, `borrow`), пока система всё ещё считает, что залог находится внутри контракта.

### 3. Insolvency Logic Error (Euler Finance)
* **Тип:** Ошибка бизнес-логики (Business Logic Error) / Манипуляция состоянием.
* **Механика:** Функция пожертвования (`donateToReserves`) позволяет пользователю отдать свой залог в резервы протокола, но не проверяет, остается ли позиция пользователя «здоровой» (Solvent) после этого действия. Атакующий намеренно делает себя банкротом через пожертвование, а затем сам себя ликвидирует. Механизм ликвидации выплачивает ему «бонус» из резервов (которые он сам же и пополнил), и математическая модель бонуса позволяет вывести из протокола больше средств, чем было потрачено на погашение долга.

### 4. Timestamp Dependence (EtherLotto)
* **Тип**: Ошибка источника случайности (Weak Randomness) / Манипуляция детерминированным результатом.
* **Механика**: Контракт лотереи использует `block.timestamp` как единственный источник для генерации "случайного" числа `(uint(sha3(block.timestamp)) % 2)`. Майнер (или атакующий, использующий локальную ноду) может контролировать временную метку блока в пределах нескольких секунд. Атакующий вычисляет, при каком значении `timestamp` результат операции будет равен нулю, и отправляет свою транзакцию так, чтобы она попала в блок с подходящей временной меткой. Это гарантирует, что атакующий всегда выигрывает, получая джекпот. Уязвимость критична, поскольку делает игру полностью предсказуемой для того, кто может влиять на время блока.

### 5. Flash Loan Reserve Desync (DODO)
* **Тип**: Ошибка синхронизации состояния (State Synchronization Error) / Манипуляция внутренней бухгалтерией.
* **Механика**: Протокол DODO допускал несоответствие между реальным балансом токенов в пуле (`balanceOf`) и внутренними учетными записями резервов (`reserveA/reserveB`). При выдаче флеш-займа реальный баланс пула уменьшался, но внутренние резервы не обновлялись. Функция swap для расчета цены обмена использовала устаревшие значения резервов. Атакующий брал флеш-займ, временно уменьшая реальный баланс пула, затем выполнял обмен по завышенному курсу (так как формула `amountOut = (amountIn * reserveB) / (reserveA + amountIn)` использовала некорректное, большее значение `reserveA`). После возврата займа протокол восстанавливал баланс, но атакующий уже получал прибыль за счет искаженной цены. Уязвимость была в непоследовательном обновлении состояния — изменении баланса без изменения резервов.

### 6. Reentrancy (The DAO Attack)
* **Тип**: Нарушение порядка выполнения (Execution Order Violation) / Повторный вход.
* **Механика**: Контракт The DAO использовал уязвимый порядок операций в функции вывода средств: сначала выполнялась внешняя отправка ETH (call.value), и только затем обновлялся внутренний баланс пользователя. Атакующий контракт в своей `fallback` (или `receive`) функции, которая автоматически вызывалась при получении ETH, снова рекурсивно вызывал уязвимую функцию вывода. Поскольку внутренний баланс атакующего еще не был уменьшен после первой отправки, проверка `require(balances[msg.sender] >= _amount)` проходила снова, позволяя украсть средства многократно за одну транзакцию. Это классическое нарушение паттерна "Checks-Effects-Interactions", где "Взаимодействия" (`external calls`) должны выполняться после всех "Эффектов" (`state changes`).
