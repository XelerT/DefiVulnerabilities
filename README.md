### Structure

    src  - sources with vulnerable smart contracts
    test - files that will be run by forge

# Описание реализованных уязвимостей (Vulnerability Showcase)


---

### 1. Arbitrary External Call (SushiSwap RouteProcessor2)
* **Тип:** Нарушение валидации входных данных (Input Validation) / Access Control.
* **Механика:** Смарт-контракт роутера слепо доверяет параметрам маршрутизации (`route`), переданным пользователем, и декодирует из них адрес пула без проверки по «белому списку». Атакующий подставляет в маршрут адрес своего вредоносного контракта. Роутер, следуя инструкции, отправляет токены пользователя (или свои) на этот адрес, где вредоносный код похищает их вместо выполнения обмена.

### 2. Token Callback Reentrancy (Omni Protocol / NFT)
* **Тип:** Атака повторного входа (Reentrancy) через стандарты токенов (ERC-721, ERC-777, ERC-1155).
* **Механика:** Протокол нарушает паттерн **Checks-Effects-Interactions**: он сначала отправляет актив (NFT) пользователю, и только потом обновляет запись о долге или залоге. Токены стандарта ERC-721 при получении автоматически вызывают функцию-хук (`onERC721Received`) у получателя. Атакующий использует этот момент, чтобы повторно вызвать функцию протокола (например, `borrow`), пока система всё ещё считает, что залог находится внутри контракта.

### 3. Insolvency Logic Error (Euler Finance)
* **Тип:** Ошибка бизнес-логики (Business Logic Error) / Манипуляция состоянием.
* **Механика:** Функция пожертвования (`donateToReserves`) позволяет пользователю отдать свой залог в резервы протокола, но не проверяет, остается ли позиция пользователя «здоровой» (Solvent) после этого действия. Атакующий намеренно делает себя банкротом через пожертвование, а затем сам себя ликвидирует. Механизм ликвидации выплачивает ему «бонус» из резервов (которые он сам же и пополнил), и математическая модель бонуса позволяет вывести из протокола больше средств, чем было потрачено на погашение долга.

### 4. Timestamp Dependence (EtherLotto)
* **Тип**: Ошибка источника случайности (Weak Randomness) / Манипуляция детерминированным результатом.
* **Механика**: Контракт лотереи использует `block.timestamp` как единственный источник для генерации "случайного" числа `(uint(sha3(block.timestamp)) % 2)`. Майнер (или атакующий, использующий локальную ноду) может контролировать временную метку блока в пределах нескольких секунд. Атакующий вычисляет, при каком значении `timestamp` результат операции будет равен нулю, и отправляет свою транзакцию так, чтобы она попала в блок с подходящей временной меткой. Это гарантирует, что атакующий всегда выигрывает, получая джекпот. Уязвимость критична, поскольку делает игру полностью предсказуемой для того, кто может влиять на время блока.

### 5. Flash Loan Reserve Desync (DODO)
* **Тип**: Ошибка синхронизации состояния (State Synchronization Error) / Манипуляция внутренней бухгалтерией.
* **Механика**: Протокол DODO допускал несоответствие между реальным балансом токенов в пуле (`balanceOf`) и внутренними учетными записями резервов (`reserveA/reserveB`). При выдаче флеш-займа реальный баланс пула уменьшался, но внутренние резервы не обновлялись. Функция swap для расчета цены обмена использовала устаревшие значения резервов. Атакующий брал флеш-займ, временно уменьшая реальный баланс пула, затем выполнял обмен по завышенному курсу (так как формула `amountOut = (amountIn * reserveB) / (reserveA + amountIn)` использовала некорректное, большее значение `reserveA`). После возврата займа протокол восстанавливал баланс, но атакующий уже получал прибыль за счет искаженной цены. Уязвимость была в непоследовательном обновлении состояния — изменении баланса без изменения резервов.

### 6. Reentrancy (The DAO Attack)
* **Тип**: Нарушение порядка выполнения (Execution Order Violation) / Повторный вход.
* **Механика**: Контракт The DAO использовал уязвимый порядок операций в функции вывода средств: сначала выполнялась внешняя отправка ETH (call.value), и только затем обновлялся внутренний баланс пользователя. Атакующий контракт в своей `fallback` (или `receive`) функции, которая автоматически вызывалась при получении ETH, снова рекурсивно вызывал уязвимую функцию вывода. Поскольку внутренний баланс атакующего еще не был уменьшен после первой отправки, проверка `require(balances[msg.sender] >= _amount)` проходила снова, позволяя украсть средства многократно за одну транзакцию. Это классическое нарушение паттерна "Checks-Effects-Interactions", где "Взаимодействия" (`external calls`) должны выполняться после всех "Эффектов" (`state changes`).

### 7. Unrestricted Permissionless Liquidation
* **Тип**: Нарушение контроля доступа (Access Control) / Ошибка бизнес-логики (Business Logic Error).
* **Механика**: Контракт кредитования позволяет любому пользователю ликвидировать любую позицию через функцию ```liquidate(address user)``` без проверки условий ликвидации (health factor, отношение залога к долгу, временные задержки). Атакующий может немедленно ликвидировать только что созданную здоровую позицию, присвоив весь залог при минимальном долге. В ранних DeFi протоколах это приводило к "атакам ликвидации", где боты отслеживали мемпул и ликвидировали позиции до того, как они становились фактически несостоятельными.


### 8. Funds Locking in Non-Payable Contracts
* **Тип**: Ошибка обработки ошибок (Error Handling) / Непроверенные внешние вызовы (Unchecked External Calls)
* **Механика**: Контракт аукциона использует ```payable(owner).transfer(highestBid)``` для отправки выигрыша владельцу. Если владелец является контрактом без ```receive()``` или ```fallback()``` функций, или с функциями, которые используют ```revert()```, перевод ETH откатится, но аукцион уже отмечен как завершенный ```(ended = true)```. Средства навсегда блокируются в контракте без механизма восстановления. Этот паттерн привел к блокировке 1100 ETH в контракте Governmental и миллионам долларов в различных ранних смарт-контрактах.

### 9. ERC20 Approval Front-Running Race Condition
* **Тип**: Гонка условий (Race Condition) / Front-running атака
* **Механика**: Стандарт ERC20 ```approve()``` функция уязвима к front-running атакам при изменении существующего разрешения. Если пользователь хочет изменить разрешение с 5 токенов на 3, он отправляет транзакцию ```approve(spender, 3)```. Атакующий, наблюдая за мемпулом, может отправить транзакцию ```transferFrom(user, attacker, 5)``` с более высокой газовой ценой. Когда транзакции исполняются, атакующий сначала получает 5 токенов, затем разрешение обновляется до 3, и атакующий может взять еще 3 токена, получив в сумме 8 вместо разрешенных 3. Эта уязвимость присуща стандарту ERC20 и до сих пор актуальна.