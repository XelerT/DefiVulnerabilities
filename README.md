### Structure

    src  - sources with vulnerable smart contracts
    test - files that will be run by forge

# Описание реализованных уязвимостей (Vulnerability Showcase)


---

### 1. Arbitrary External Call (SushiSwap RouteProcessor2)
* **Тип:** Нарушение валидации входных данных (Input Validation) / Access Control.
* **Механика:** Смарт-контракт роутера слепо доверяет параметрам маршрутизации (`route`), переданным пользователем, и декодирует из них адрес пула без проверки по «белому списку». Атакующий подставляет в маршрут адрес своего вредоносного контракта. Роутер, следуя инструкции, отправляет токены пользователя (или свои) на этот адрес, где вредоносный код похищает их вместо выполнения обмена.

### 2. Token Callback Reentrancy (Omni Protocol / NFT)
* **Тип:** Атака повторного входа (Reentrancy) через стандарты токенов (ERC-721, ERC-777, ERC-1155).
* **Механика:** Протокол нарушает паттерн **Checks-Effects-Interactions**: он сначала отправляет актив (NFT) пользователю, и только потом обновляет запись о долге или залоге. Токены стандарта ERC-721 при получении автоматически вызывают функцию-хук (`onERC721Received`) у получателя. Атакующий использует этот момент, чтобы повторно вызвать функцию протокола (например, `borrow`), пока система всё ещё считает, что залог находится внутри контракта.

### 3. Insolvency Logic Error (Euler Finance)
* **Тип:** Ошибка бизнес-логики (Business Logic Error) / Манипуляция состоянием.
* **Механика:** Функция пожертвования (`donateToReserves`) позволяет пользователю отдать свой залог в резервы протокола, но не проверяет, остается ли позиция пользователя «здоровой» (Solvent) после этого действия. Атакующий намеренно делает себя банкротом через пожертвование, а затем сам себя ликвидирует. Механизм ликвидации выплачивает ему «бонус» из резервов (которые он сам же и пополнил), и математическая модель бонуса позволяет вывести из протокола больше средств, чем было потрачено на погашение долга.

### 4. Timestamp Dependence (EtherLotto)
* **Тип**: Ошибка источника случайности (Weak Randomness) / Манипуляция детерминированным результатом.
* **Механика**: Контракт лотереи использует `block.timestamp` как единственный источник для генерации "случайного" числа `(uint(sha3(block.timestamp)) % 2)`. Майнер (или атакующий, использующий локальную ноду) может контролировать временную метку блока в пределах нескольких секунд. Атакующий вычисляет, при каком значении `timestamp` результат операции будет равен нулю, и отправляет свою транзакцию так, чтобы она попала в блок с подходящей временной меткой. Это гарантирует, что атакующий всегда выигрывает, получая джекпот. Уязвимость критична, поскольку делает игру полностью предсказуемой для того, кто может влиять на время блока.

### 5. Flash Loan Reserve Desync (DODO)
* **Тип**: Ошибка синхронизации состояния (State Synchronization Error) / Манипуляция внутренней бухгалтерией.
* **Механика**: Протокол DODO допускал несоответствие между реальным балансом токенов в пуле (`balanceOf`) и внутренними учетными записями резервов (`reserveA/reserveB`). При выдаче флеш-займа реальный баланс пула уменьшался, но внутренние резервы не обновлялись. Функция swap для расчета цены обмена использовала устаревшие значения резервов. Атакующий брал флеш-займ, временно уменьшая реальный баланс пула, затем выполнял обмен по завышенному курсу (так как формула `amountOut = (amountIn * reserveB) / (reserveA + amountIn)` использовала некорректное, большее значение `reserveA`). После возврата займа протокол восстанавливал баланс, но атакующий уже получал прибыль за счет искаженной цены. Уязвимость была в непоследовательном обновлении состояния — изменении баланса без изменения резервов.

### 6. Reentrancy (The DAO Attack)
* **Тип**: Нарушение порядка выполнения (Execution Order Violation) / Повторный вход.
* **Механика**: Контракт The DAO использовал уязвимый порядок операций в функции вывода средств: сначала выполнялась внешняя отправка ETH (call.value), и только затем обновлялся внутренний баланс пользователя. Атакующий контракт в своей `fallback` (или `receive`) функции, которая автоматически вызывалась при получении ETH, снова рекурсивно вызывал уязвимую функцию вывода. Поскольку внутренний баланс атакующего еще не был уменьшен после первой отправки, проверка `require(balances[msg.sender] >= _amount)` проходила снова, позволяя украсть средства многократно за одну транзакцию. Это классическое нарушение паттерна "Checks-Effects-Interactions", где "Взаимодействия" (`external calls`) должны выполняться после всех "Эффектов" (`state changes`).

### 7. Gas Griefing in Auction Withdrawals
* **Тип**: Атака на расход газа (Gas Attack) / Отказ в обслуживании (Denial of Service).
* **Механика**: Контракт аукциона использует низкий лимит газа (2300) при возврате средств проигравшим участникам через вызов ```msg.sender.call{value: amount, gas: 2300}("")```. Если участник является контрактом с дорогостоящей ```receive()``` или ```fallback()``` функцией, требующей более 2300 газа, транзакция откатится. Однако состояние уже обновлено ```(pendingReturns[msg.sender] = 0)```, что делает средства навсегда недоступными для вывода. Эта уязвимость использовалась в ранних версиях аукционов, где участники теряли свои ставки из-за несовместимости с контрактами-получателями.

### 8. Unrestricted Permissionless Liquidation
* **Тип**: Нарушение контроля доступа (Access Control) / Ошибка бизнес-логики (Business Logic Error).
* **Механика**: Контракт кредитования позволяет любому пользователю ликвидировать любую позицию через функцию ```liquidate(address user)``` без проверки условий ликвидации (health factor, отношение залога к долгу, временные задержки). Атакующий может немедленно ликвидировать только что созданную здоровую позицию, присвоив весь залог при минимальном долге. В ранних DeFi протоколах это приводило к "атакам ликвидации", где боты отслеживали мемпул и ликвидировали позиции до того, как они становились фактически несостоятельными.


### 9. Funds Locking in Non-Payable Contracts
* **Тип**: Ошибка обработки ошибок (Error Handling) / Непроверенные внешние вызовы (Unchecked External Calls)
* **Механика**: Контракт аукциона использует ```payable(owner).transfer(highestBid)``` для отправки выигрыша владельцу. Если владелец является контрактом без ```receive()``` или ```fallback()``` функций, или с функциями, которые используют ```revert()```, перевод ETH откатится, но аукцион уже отмечен как завершенный ```(ended = true)```. Средства навсегда блокируются в контракте без механизма восстановления. Этот паттерн привел к блокировке 1100 ETH в контракте Governmental и миллионам долларов в различных ранних смарт-контрактах.

### 10. ERC20 Approval Front-Running Race Condition
* **Тип**: Гонка условий (Race Condition) / Front-running атака
* **Механика**: Стандарт ERC20 ```approve()``` функция уязвима к front-running атакам при изменении существующего разрешения. Если пользователь хочет изменить разрешение с 5 токенов на 3, он отправляет транзакцию ```approve(spender, 3)```. Атакующий, наблюдая за мемпулом, может отправить транзакцию ```transferFrom(user, attacker, 5)``` с более высокой газовой ценой. Когда транзакции исполняются, атакующий сначала получает 5 токенов, затем разрешение обновляется до 3, и атакующий может взять еще 3 токена, получив в сумме 8 вместо разрешенных 3. Эта уязвимость присуща стандарту ERC20 и до сих пор актуальна.

### 11. ERC20 Approval Front-Running Race Condition
* **Тип**: Ошибка проверки адреса (Address Validation) / Потеря активов (Asset Loss)
* **Механика**: Контракт токена позволяет переводы на любые адреса, включая контракты, которые не предназначены для хранения или управления ERC20 токенами. Когда токены отправляются на адрес контракта без функций для их передачи обратно (например, простой контракт без функций взаимодействия с ERC20), они навсегда блокируются. Это распространенная ошибка в airdrop кампаниях и массовых рассылках, где токены отправляются на адреса контрактов без проверки их совместимости.